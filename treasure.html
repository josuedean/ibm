<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Ensures proper scaling on mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D ASCII Chalice</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Tangerine:wght@700&display=swap">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
    }
    .title {
      font-family: 'Tangerine', cursive;
      font-size: 32px;
      color: gold;
      text-align: center;
      margin: 20px 0;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
      max-width: 80%;
      z-index: 10;
    }

    /* Original style for ASCII container. 
       (No center/flex that would reduce the number of columns/rows!) */
    #ascii-container {
      white-space: pre;
      line-height: 0.9;
      font-size: 10px;
      letter-spacing: -0.5px;
    }
  </style>
</head>
<body>
  <div class="title">An intricately rendered chalice made entirely of ASCII characters, awarded to true text-command masters.</div>
  <!-- We put this container in the DOM, but note that below we still append 
       the ASCII effect directly to the BODY. Thatâ€™s the original approach. -->
  <div id="ascii-container"></div>

  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/effects/AsciiEffect.js"></script>
  <script>
    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      60, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 2.5, 5);
    camera.lookAt(0, 1, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    const frontLight = new THREE.DirectionalLight(0xffffff, 1.2);
    frontLight.position.set(5, 5, 5);
    scene.add(frontLight);

    const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
    backLight.position.set(-5, 3, -5);
    scene.add(backLight);

    const sideLight = new THREE.DirectionalLight(0xffffff, 0.4);
    sideLight.position.set(5, 0, -5);
    scene.add(sideLight);

    // Chalice geometry
    const chaliceGroup = new THREE.Group();
    scene.add(chaliceGroup);

    const points = [];
    points.push(new THREE.Vector2(0.05, 0.0));
    points.push(new THREE.Vector2(1.0, 0.0));
    points.push(new THREE.Vector2(0.9, 0.05));
    points.push(new THREE.Vector2(0.8, 0.1));
    points.push(new THREE.Vector2(0.9, 0.2));
    points.push(new THREE.Vector2(0.5, 0.3));
    points.push(new THREE.Vector2(0.4, 0.6));
    points.push(new THREE.Vector2(0.5, 0.9));
    points.push(new THREE.Vector2(0.7, 1.1));
    points.push(new THREE.Vector2(0.9, 1.3));
    points.push(new THREE.Vector2(1.0, 1.5));
    points.push(new THREE.Vector2(1.1, 1.7));
    points.push(new THREE.Vector2(1.2, 1.75));
    points.push(new THREE.Vector2(1.1, 1.8));
    points.push(new THREE.Vector2(1.2, 1.85));
    points.push(new THREE.Vector2(1.1, 1.9));
    points.push(new THREE.Vector2(1.2, 1.95));
    points.push(new THREE.Vector2(1.0, 2.0));

    const geometry = new THREE.LatheGeometry(points, 192); // High segment count
    const material = new THREE.MeshPhongMaterial({
      color: 0xffd700,
      shininess: 120,
      specular: 0xffffdd,
      side: THREE.DoubleSide
    });
    const chalice = new THREE.Mesh(geometry, material);
    chalice.scale.set(1.5, 1.5, 1.5);
    chaliceGroup.add(chalice);

    // Handles
    const handleWidth = 0.15;
    const handleShape = new THREE.Shape();
    handleShape.ellipse(0, 0, handleWidth, handleWidth, 0, Math.PI * 2);

    const leftCurve = new THREE.CubicBezierCurve3(
      new THREE.Vector3(-0.6, 0.7, 0),
      new THREE.Vector3(-1.4, 0.9, 0),
      new THREE.Vector3(-1.4, 1.4, 0),
      new THREE.Vector3(-0.9, 1.5, 0)
    );
    const leftHandleGeometry = new THREE.ExtrudeGeometry(handleShape, {
      steps: 40,
      bevelEnabled: false,
      extrudePath: leftCurve
    });
    const leftHandle = new THREE.Mesh(leftHandleGeometry, material);
    leftHandle.scale.set(1.5, 1.5, 1.5);
    chaliceGroup.add(leftHandle);

    const rightCurve = new THREE.CubicBezierCurve3(
      new THREE.Vector3(0.6, 0.7, 0),
      new THREE.Vector3(1.4, 0.9, 0),
      new THREE.Vector3(1.4, 1.4, 0),
      new THREE.Vector3(0.9, 1.5, 0)
    );
    const rightHandleGeometry = new THREE.ExtrudeGeometry(handleShape, {
      steps: 40,
      bevelEnabled: false,
      extrudePath: rightCurve
    });
    const rightHandle = new THREE.Mesh(rightHandleGeometry, material);
    rightHandle.scale.set(1.5, 1.5, 1.5);
    chaliceGroup.add(rightHandle);

    chaliceGroup.rotation.z = Math.PI * 0.05;
    chaliceGroup.rotation.x = Math.PI * 0.15;

    // ASCII Effect (with resolution=0.1 for high detail)
    const ascii = new THREE.AsciiEffect(renderer, ' .,:;i1tfLCG08@', {
      invert: true,
      resolution: 0.1
    });
    ascii.setSize(window.innerWidth, window.innerHeight);

    // Here is the crucial step: we append to BODY, like the original did
    document.body.appendChild(ascii.domElement);

    // Make the ASCII element respond to pinch/rotate:
    ascii.domElement.style.touchAction = 'none';  // Prevent browser zoom/scroll
    ascii.domElement.style.userSelect = 'none';   // Disable text selection highlight

    // OrbitControls
    const controls = new THREE.OrbitControls(camera, ascii.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    // Keep auto-rotate for that lively spinning
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.0;

    // Let user pinch to zoom, single finger to rotate
    // (Default "TWO: THREE.TOUCH.DOLLY_PAN" is pinch-to-zoom plus 2-finger drag to pan)
    controls.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN
    };

    // Zoom range
    controls.minDistance = 1;
    controls.maxDistance = 20;

    // Handle resizing
    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      ascii.setSize(width, height);
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      ascii.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
